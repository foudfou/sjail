#!/bin/sh
set -ue

freebsd_url=https://download.freebsd.org/releases/amd64/amd64/
zfs_options="-o compress=lz4 -o atime=off"

base_dir=$(dirname $(realpath $0))

log_fatal() {
    msg=$1
    echo "Error: ${msg}" 1>&2
    exit 1
}

. /usr/local/etc/sjail.conf

sysrc_silent() {
    sysrc "$1" >/dev/null
}

sjail_init() {
    if [ -e /usr/local/etc/sjail.conf ]; then
        log_fatal "/usr/local/etc/sjail.conf already exists"
    fi

    zfs create ${zfs_options} -o mountpoint=${zfs_mount} ${zfs_pool}

    if ! grep -q '.include "'${zfs_mount}/jails /etc/jail.conf; then
        cat <<EOF > /etc/jail.conf
.include "${zfs_mount}/jails/*/jail.conf";
EOF
    fi

    sysrc_silent jail_enable="YES"
    sysrc_silent jail_parallel_start="YES"

    sysrc_silent cloned_interfaces+="lo1"
    service netif cloneup
}

sjail_fetch() {
    local version="$1"
    echo "Creating release ${version}"

    if [ -e "${zfs_mount}/releases/${version}" ]; then
        log_fatal "$version already fetched"
    fi

    zfs create ${zfs_options} -p ${zfs_pool}/releases/${version}

    fetch "${freebsd_url}/${version}/MANIFEST" -o /tmp/MANIFEST

    local release_archives="base" a
    for a in ${release_archives}; do
        local archive="${a}.txz"
        rm -f /tmp/${archive} || true
        fetch "${freebsd_url}/${version}/${archive}" -o /tmp/${archive}

        local checksum_want=$(grep -w ${archive} /tmp/MANIFEST | cut -f2)
        local checksum_got=$(sha256 -q /tmp/${archive})
        if [ "${checksum_got}" != "${checksum_want}" ]; then
            log_fatal "wrong checksum for ${archive}: ${checksum_got}"
        fi

        tar -xf /tmp/${archive} -C "${zfs_mount}/releases/${version}"
    done
}

sjail_update() {
    local version="$1"
    echo "Updating release ${version}"
    freebsd-update --currently-running ${version} -b ${zfs_mount}/releases/${version} fetch install
    # freebsd-update --currently-running ${version} -b ${zfs_mount}/releases/${version} IDS
}

arg_get() {
    local opt=$1; shift
    echo "$@" | awk 'BEGIN{RS=" ";FS="="} /'${opt}'/ {print $2}'
}

sjail_create() {
    local jail_name="$1"; shift
    local version="$1"; shift
    local ip4=$(arg_get ip4 "$@")
    local ip6=$(arg_get ip6 "$@")
    echo "Creating thin jail: $jail_name"

    zfs create -p ${zfs_options} "${zfs_pool}/jails/${jail_name}"

    local jail_path="${zfs_mount}/jails/${jail_name}"
    cat <<EOF > ${jail_path}/fstab
${zfs_mount}/releases/${version} ${jail_path}/root/.ro nullfs ro 0 0
EOF

    local ip4_addr=""
    if [ -n "${ip4}" ]; then
        ip4_addr="ip4.addr = ${ip4};"
    fi
    local ip6_addr=""
    local ip6_mode="ip6 = disable;"
    if [ -n "${ip6}" ]; then
        ip6_addr="ip6.addr = ${ip6};"
        ip6_mode="ip6 = new;"
    fi

    cat << EOF > "${jail_path}/jail.conf"
${jail_name} {
  host.hostname = ${jail_name};
  path = ${jail_path}/root;

  exec.clean;
  exec.consolelog = ${jail_path}/console.log;
  exec.start = '/bin/sh /etc/rc';
  exec.stop = '/bin/sh /etc/rc.shutdown';
  exec.prestart += "cp /etc/resolv.conf.jails \$path/etc/resolv.conf";
  exec.prestart += "cp /etc/localtime \$path/etc";
  exec.poststop += "rm \$path/etc/resolv.conf";
  exec.poststop += "rm \$path/etc/localtime";

  mount.devfs;
  mount.fstab = ${jail_path}/fstab;
  enforce_statfs = 2;
  devfs_ruleset = 4;

  securelevel = 2;
  osrelease = ${version};

  interface = ${interface};
  ${ip4_addr}
  ${ip6_addr}
  ${ip6_mode}
}
EOF

    mkdir "${jail_path}/root"
    cd "${jail_path}/root"

    mkdir .ro
    mkdir usr
    local ro="bin boot lib libexec rescue sbin usr/bin usr/include usr/lib usr/lib32 usr/libdata usr/libexec usr/sbin usr/share usr/src" l
    for l in ${ro}; do
      ln -Fsf /.ro/${l} ${l}
    done

    local rw=".cshrc .profile COPYRIGHT dev etc media mnt net proc root tmp var usr/obj usr/tests" files
    for files in ${rw}; do
      cp -a "${zfs_mount}/releases/${version}/${files}" "${jail_path}/root/${files}"
    done

    # minor adjustments
    mkdir -p usr/home
    ln -s usr/home home
    touch etc/fstab

    cd -

    sysrc_silent jail_list+="${jail_name}"
}

sjail_destroy() {
    local jail_name="$1"

    if jls -j ${jail_name} >/dev/null 2>&1; then
        log_fatal "jail running. Stop first."
    fi

    zfs destroy -r ${zfs_pool}/jails/${jail_name}

    sysrc_silent jail_list-="${jail_name}"
}

output_get_word() {
    echo -e "$1" | grep -w "$2" || true
}

sjail_list() {
    local format all running status release j

    format="%-10s %-8s %-13s %15s %3s\n"
    printf "${format}" Jail Status Release

    all=$(jail -e'|' '*' | sort)
    all=$(echo -e "$all" | cut -d'|' -f1 | cut -d= -f2)
    running=$(jls -N)
    for j in ${all}; do
        status=$(output_get_word "${running}" "${j}")
        if [ -n "${status}" ]; then
            status=Up
        else
            status=Down
        fi

        release=$(output_get_word "${all_info}" "name=${j}")
        release=$(echo -n "${release}" | awk 'BEGIN{RS="|";FS="="} /mount.fstab/ {print $2}')
        if [ -n "${release}" ]; then
            release=$(grep releases "${release}" | cut -d' ' -f1 || true)
            release=${release##*/}
        else
            release=-
        fi

        printf "${format}" ${j} ${status} ${release}
    done
}

usage() {
    cat <<EOF
Usage: `basename $0` COMMAND [args]

Commands:
    init                 Setup zpool
    fetch VERSION        Fetch and create base template for version VERSION
                         (e.g. 14.1-RELEASE)
    update VERSION       Apply freebsd-update on base template with version
                         VERSION. Can be done anytime.
    create NAME VERSION  Create thin jail NAME from base template with version
                         VERSION.
    destroy NAME         Destroy thin jail NAME.
    list                 List status of all jails.
EOF
}

if [ $# -lt 1 ]; then
    usage
    exit 1
fi

case "$1" in
    help|-h|--help)
        usage
        exit 0
        ;;
esac

if [ "$(id -u)" -ne 0 ]; then
    log_fatal "not root"
fi

command=${1}; shift
case $command in
    init)
        sjail_init
        ;;
    fetch)
        sjail_fetch "$@"
        ;;
    update)
        sjail_update "$@"
        ;;
    create)
        sjail_create "$@"
        ;;
    destroy)
        sjail_destroy "$@"
        ;;
    list)
        sjail_list
        ;;
    *)
        usage
        ;;
esac
